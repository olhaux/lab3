-- -- TASK 1
-- land borders as undirected by listing both country1–country2 and country2–country1.
-- Count the number of distinct neighboring countries per country in a CTE.
-- Compute the global minimum neighbor count across all countries.
-- Filter to only those countries whose neighbor count equals this global minimum.
-- Join with Country to show country names and orders the result alphabetically.
WITH neighbor_counts_cte AS (
    SELECT country, COUNT(DISTINCT neighbor) AS num
    FROM (
        SELECT country1 AS country, country2 AS neighbor FROM borders
        UNION ALL
        SELECT country2 AS country, country1 AS neighbor FROM borders
    ) AS border_found
    GROUP BY country
),
min_neighbors AS (
    SELECT MIN(num) AS min_num
    FROM neighbor_counts_cte
)
SELECT country.name, nc_cte.num
FROM neighbor_counts_cte nc_cte
JOIN min_neighbors ON nc_cte.num = min_neighbors.min_num
JOIN country ON country.code = nc_cte.country
ORDER BY country.name;

-- -- TASK 2
-- Multiply each country’s population by the percentage speaking a language to estimate speakers.
-- Ignore rows where population or percentage is NULL to avoid incorrect arithmetic.
-- Aggregate the  speakers per language across all countries.
-- Roundsthe total number of speakers to the nearest integer.
-- Order languages by estimated number of speakers in descending order.
SELECT
    spoken.language,
    ROUND(SUM(country.population * (spoken.percentage / 100))) AS speakers
FROM spoken
JOIN country ON country.code = spoken.country
WHERE country.population IS NOT NULL AND spoken.percentage IS NOT NULL
GROUP BY spoken.language    
ORDER BY speakers DESC;

-- -- TASK 3
-- Build an undirected list of neighboring country pairs via the borders table.
-- Join economy data twice to associate each country in the pair with its GDP.
-- Use NULLIF in the denominator to avoid division by zero when computing GDP ratios.
-- Filter out non-positive GDP values to keep ratios meaningful.
-- Order neighbor pairs by the GDP ratio (country1 / country2) in descending order.
WITH neighbor_pair AS (
  SELECT country1 AS country, country2 AS neighbor FROM borders
  UNION ALL
  SELECT country2 AS country, country1 AS neighbor FROM borders
),
gdp_pair AS (
  SELECT c1.Code AS country1, c2.Code AS country2, e1.GDP AS gdp1, e2.GDP AS gdp2, ROUND(e1.GDP / NULLIF(e2.GDP, 0)) AS ratio
  FROM neighbor_pair np
  JOIN economy e1 ON e1.country = np.country
  JOIN economy e2 ON e2.country = np.neighbor
  JOIN country c1 ON c1.code = np.country
  JOIN country c2 ON c2.code = np.neighbor
  WHERE e1.GDP > 0 AND e2.GDP > 0
)
SELECT *
FROM gdp_pair
ORDER BY ratio DESC;

-- P+ TASK1
-- Initialize the recursive CTE with Sweden as the starting node (0 crossings).
-- Recursively follow all land borders to neighboring countries and increase the crossing count by 1.
-- Limit recursion depth to a maximum of 5 crossings to prevent infinite expansion.
-- After recursion, exclude Sweden and compute the minimal number of crossings required to reach each country.
-- Output each reachable country with its minimal crossing count, ordered by crossings and country code.
-- snc = countries already reached, c = country reachable by border, b = boarder connection
WITH RECURSIVE SwedenNeighborCountries(code, name, min) AS (

    -- Start at Sweden
    SELECT c.code AS country_code, c.name AS country_name, 0 AS min
    FROM country c
    WHERE c.code = 'S'

    UNION ALL

    -- Recursive step expand to neighbors
    SELECT c.code AS country_code, c.name AS country_name, snc.min + 1 AS min
    FROM SwedenNeighborCountries snc
    JOIN (
        SELECT country1 AS country, country2 AS neighbor FROM borders
        UNION ALL
        SELECT country2 AS country, country1 AS neighbor FROM borders
    ) b
    ON b.country = snc.code 
    JOIN country c ON c.code = b.neighbor
    WHERE snc.min < 5
)

SELECT code, name, MIN(min) AS min_crossings
FROM SwedenNeighborCountries
WHERE code != 'S'
GROUP BY name, code
ORDER BY min_crossings ASC;


-- P+ Task2
-- Focuses on a selected set of main rivers as starting points of recursive exploration.
-- Recursively follows rivers relationships to build full river branches and tracks the path.
-- Accumulates both the total length and the number of rivers in each branch.
-- Restricts to leaf branches that cannot be extended by further rivers.
-- For each main river system, keeps only the branch(es) with the largest number of rivers and ranks them.
WITH RECURSIVE river_branch AS (
    -- start at each selected main river
    SELECT
        r.name AS current_river,
        r.name AS main_river,
        r.length AS total_length,
        1 AS num_rivers,
        r.name::TEXT AS path -- Convert name to text
    FROM river r
    WHERE r.name IN ('Nile', 'Amazonas', 'Yangtze', 'Rhein', 'Donau', 'Mississippi')

    UNION ALL
    -- Recursive step
    SELECT
        child.name,
        rb.main_river,
        rb.total_length + child.length,
        rb.num_rivers + 1,
        rb.path || '-' || child.name -- path must be a string
    FROM river child
    JOIN river_branch rb ON child.river = rb.current_river
),
-- Keep only branches that cannot be extended further
check_ends AS (
    SELECT
        main_river,
        path,
        num_rivers,
        total_length
    FROM river_branch rb
    WHERE NOT EXISTS (
        SELECT 1 FROM river c WHERE c.river = rb.current_river
    )
),
-- For each main river, keep branch with the maximum number of rivers
longest_per_system AS (
    SELECT ends.*
    FROM check_ends ends
    JOIN (
        SELECT main_river, MAX(num_rivers) AS max_rivers
        FROM check_ends
        GROUP BY main_river
    ) mx
      ON ends.main_river = mx.main_river
     AND ends.num_rivers = mx.max_rivers
)
SELECT
    RANK() OVER (ORDER BY num_rivers) AS rank, -- rank by branch length
    path,
    num_rivers,
    total_length
FROM longest_per_system
ORDER BY num_rivers, total_length;
