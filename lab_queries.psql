-- -- TASK 1
-- Standardises land borders as undirected by listing both country1–country2 and country2–country1.
-- Counts the number of distinct neighboring countries per country in a CTE.
-- Computes the global minimum neighbor count across all countries.
-- Filters to only those countries whose neighbor count equals this global minimum.
-- Joins with Country to show country names and orders the result alphabetically.
WITH neighbor_counts_cte AS (
    SELECT country, COUNT(DISTINCT neighbor) AS num
    FROM (
        SELECT country1 AS country, country2 AS neighbor FROM borders
        UNION ALL
        SELECT country2 AS country, country1 AS neighbor FROM borders
    ) AS border_found
    GROUP BY country
),
min_neighbors AS (
    SELECT MIN(num) AS min_num
    FROM neighbor_counts_cte
)
SELECT country.name, nc_cte.num
FROM neighbor_counts_cte nc_cte
JOIN min_neighbors ON nc_cte.num = min_neighbors.min_num
JOIN country ON country.code = nc_cte.country
ORDER BY country.name;

-- -- TASK 2
-- Multiplies each country’s population by the percentage speaking a language to estimate speakers.
-- Ignores rows where population or percentage is NULL to avoid incorrect arithmetic.
-- Aggregates the  speakers per language across all countries.
-- Rounds the total number of speakers to the nearest integer.
-- Orders languages by estimated number of speakers in descending order.
SELECT
    spoken.language,
    ROUND(SUM(country.population * (spoken.percentage / 100))) AS speakers
FROM spoken
JOIN country ON country.code = spoken.country
WHERE country.population IS NOT NULL AND spoken.percentage IS NOT NULL
GROUP BY spoken.language
ORDER BY peakers DESC;

-- -- TASK 3
-- Builds an undirected list of neighboring country pairs via the borders table.
-- Joins economy data twice to associate each country in the pair with its GDP.
-- Uses NULLIF in the denominator to avoid division by zero when computing GDP ratios.
-- Filters out non-positive GDP values to keep ratios meaningful.
-- Orders neighbor pairs by the GDP ratio (country1 / country2) in descending order.
WITH neighbor_pair AS (
  SELECT country1 AS country, country2 AS neighbor FROM borders
  UNION ALL
  SELECT country2 AS country, country1 AS neighbor FROM borders
),
gdp_pair AS (
  SELECT c1.Code AS country1, c2.Code AS country2, e1.GDP AS gdp1, e2.GDP AS gdp2, ROUND(e1.GDP / NULLIF(e2.GDP, 0)) AS ratio
  FROM neighbor_pair np
  JOIN economy e1 ON e1.country = np.country
  JOIN economy e2 ON e2.country = np.neighbor
  JOIN country c1 ON c1.code = np.country
  JOIN country c2 ON c2.code = np.neighbor
  WHERE e1.GDP > 0 AND e2.GDP > 0
)
SELECT *
FROM gdp_pair
ORDER BY ratio DESC;

-- P+ TASK1
-- Starts from Swedenin a recursive CTE representing reachable countries.
-- At each step, follows all land borders to reach neighbors, increasing the crossing count by one.
-- Limits recursion depth to at most 5 border crossings to avoid infinite expansion.
-- Excludes paths that return to Sweden and then computes the minimal crossings per reached country.
-- Outputs all countries reachable from Sweden with their minimal crossing count, ordered by crossings then code.
WITH RECURSIVE Reachable AS (
    -- Level 0: Sweden itself
    SELECT c.code, 0 AS crossings
    FROM Country c
    WHERE c.name = 'Sweden'

    UNION ALL

    -- Recursive step: follow one land border
    SELECT CASE WHEN b.country1 = r.code THEN b.country2 ELSE b.country1 END AS code,
           r.crossings + 1 AS crossings
    FROM Reachable r
    JOIN borders b ON b.country1 = r.code OR b.country2 = r.code
    WHERE r.crossings < 5
      AND CASE WHEN b.country1 = r.code THEN b.country2 ELSE b.country1 END <> (SELECT code FROM Country WHERE name = 'Sweden')
)
SELECT Country.Code, Country.Name, MIN(Reachable.crossings) AS minimal_crossings
FROM Reachable
JOIN Country ON Country.Code = Reachable.code
WHERE Reachable.crossings > 0          -- exclude Sweden itself
GROUP BY Country.Code, Country.Name
ORDER BY minimal_crossings, Country.Code;

-- P+ Task2
-- Focuses on a selected set of main rivers as starting points of recursive exploration.
-- Recursively follows tributary relationships to build full river branches and tracks the path.
-- Accumulates both the total length and the number of rivers in each branch.
-- Restricts to leaf branches that cannot be extended by further tributaries.
-- For each main river system, keeps only the branch(es) with the largest number of rivers and ranks them.
WITH RECURSIVE river_branch AS (
    -- start at each selected main river
    SELECT
        r.name AS current_river,
        r.name AS main_river,
        COALESCE(r.length, 0) AS total_length,
        1 AS num_rivers,
        r.name::TEXT AS path
    FROM river r
    WHERE r.name IN ('Nile', 'Amazonas', 'Yangtze', 'Rhein', 'Donau', 'Mississippi')

    UNION ALL
    -- Recursive step
    SELECT
        child.name,
        rb.main_river,
        rb.total_length + COALESCE(child.length, 0),
        rb.num_rivers + 1,
        rb.path || '-' || child.name
    FROM river child
    JOIN river_branch rb ON child.river = rb.current_river
),
-- Keep only branches that cannot be extended further
leaf_branches AS (
    SELECT
        main_river,
        path,
        num_rivers,
        total_length
    FROM river_branch rb
    WHERE NOT EXISTS (
        SELECT 1 FROM river c WHERE c.river = rb.current_river
    )
),
-- For each main river, keep branch(es) with the maximum number of rivers
longest_per_system AS (
    SELECT lb.*
    FROM leaf_branches lb
    JOIN (
        SELECT main_river, MAX(num_rivers) AS max_rivers
        FROM leaf_branches
        GROUP BY main_river
    ) mx
      ON lb.main_river = mx.main_river
     AND lb.num_rivers = mx.max_rivers
)
SELECT
    RANK() OVER (ORDER BY num_rivers) AS rank, -- rank by branch length
    path,
    num_rivers,
    total_length
FROM longest_per_system
ORDER BY num_rivers, path;
