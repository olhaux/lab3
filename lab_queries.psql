-- -- TASK 1
-- land borders as undirected by listing both country1–country2 and country2–country1.
-- Count the number of distinct neighboring countries per country in a CTE.
-- Compute the global minimum neighbor count across all countries.
-- Filter to only those countries whose neighbor count equals this global minimum.
-- Join with Country to show country names and orders the result alphabetically.
WITH neighbor_counts_cte AS (
    SELECT country_code, COUNT(DISTINCT neighbor_code) AS num_neighbors
    FROM (
        SELECT country1 AS country_code, country2 AS neighbor_code FROM borders
        UNION ALL
        SELECT country2 AS country_code, country1 AS neighbor_code FROM borders
    ) AS border_found
    GROUP BY country_code
),
min_neighbors AS (
    SELECT MIN(num_neighbors) AS min_num_neighbors
    FROM neighbor_counts_cte
)
SELECT country.name, nc_cte.num_neighbors
FROM neighbor_counts_cte nc_cte
JOIN min_neighbors ON nc_cte.num_neighbors = min_neighbors.min_num_neighbors
JOIN country ON country.code = nc_cte.country_code
ORDER BY country.name;


-- -- TASK 2
-- Multiply each country’s population by the percentage speaking a language to estimate speakers.
-- Ignore rows where population or percentage is NULL to avoid incorrect arithmetic.
-- Aggregate the  speakers per language across all countries.
-- Roundsthe total number of speakers to the nearest integer.
-- Order languages by estimated number of speakers in descending order.
SELECT
    spoken.language,
    ROUND(SUM(country.population * (spoken.percentage / 100))) AS speakers
FROM spoken
JOIN country ON country.code = spoken.country
WHERE country.population IS NOT NULL AND spoken.percentage IS NOT NULL
GROUP BY spoken.language    
ORDER BY speakers DESC;

-- -- TASK 3
-- Build an undirected list of neighboring country pairs via the borders table.
-- Join economy data twice to associate each country in the pair with its GDP.
-- Use NULLIF in the denominator to avoid division by zero when computing GDP ratios.
-- Filter out non-positive GDP values to keep ratios meaningful.
-- Order neighbor pairs by the GDP ratio (country1 / country2) in descending order.
WITH neighbor_pair AS (
    SELECT country1 AS country_code, country2 AS neighbor_code FROM borders
    UNION ALL
    SELECT country2 AS country_code, country1 AS neighbor_code FROM borders
),
gdp_pair AS (
    SELECT c1.code AS country1, e1.GDP AS gdp1, c2.code AS country2, e2.GDP AS gdp2, ROUND(e1.GDP / NULLIF(e2.GDP, 0)) AS ratio
    FROM neighbor_pair np
    JOIN economy e1 ON e1.country = np.country_code
    JOIN economy e2 ON e2.country = np.neighbor_code
    JOIN country c1 ON c1.code = np.country_code
    JOIN country c2 ON c2.code = np.neighbor_code
    WHERE e1.GDP > 0 AND e2.GDP > 0
)
SELECT *
FROM gdp_pair
ORDER BY ratio DESC;


-- P+ TASK1
-- Initialize the recursive CTE with Sweden as the starting node (0 crossings).
-- Recursively follow all land borders to neighboring countries and increase the crossing count by 1.
-- Limit recursion depth to a maximum of 5 crossings to prevent infinite expansion.
-- After recursion, exclude Sweden and compute the minimal number of crossings required to reach each country.
-- Output each reachable country with its minimal crossing count, ordered by crossings and country code.
-- snc = countries already reached, c = country reachable by border, b = boarder connection
WITH RECURSIVE SwedenNeighborCountries(country_code, country_name, min_crossings) AS (

    -- Start at Sweden
    SELECT c.code AS country_code, c.name AS country_name, 0 AS min_crossings
    FROM country c
    WHERE c.code = 'S'

    UNION ALL

    -- Recursive step expand to neighbors
    SELECT c.code AS country_code, c.name AS country_name, snc.min_crossings + 1 AS min_crossings
    FROM SwedenNeighborCountries snc
    JOIN (
        SELECT country1 AS country_code, country2 AS neighbor_code FROM borders
        UNION ALL
        SELECT country2 AS country_code, country1 AS neighbor_code FROM borders
    ) b ON b.country_code = snc.country_code 
    JOIN country c ON c.code = b.neighbor_code
    WHERE snc.min_crossings < 5
)

SELECT country_code, country_name, MIN(min_crossings) AS min_crossings
FROM SwedenNeighborCountries
WHERE country_code != 'S'
GROUP BY country_code, country_name
ORDER BY min_crossings ASC;



-- P+ Task2
-- Focuses on a selected set of main rivers as starting points of recursive exploration.
-- Recursively follows rivers relationships to build full river branches and tracks the path.
-- Accumulates both the total length and the number of rivers in each branch.
-- Restricts to leaf branches that cannot be extended by further rivers.
-- For each main river system, keeps only the branch(es) with the largest number of rivers and ranks them.
WITH RECURSIVE river_tree (mainriver, currentriver, path, numrivers, totlength) AS (

    -- Base case start from the main rivers
    SELECT r.name AS mainriver, r.name AS currentriver, r.name::text AS path,  1 AS numrivers, r.length AS totlength
    FROM River r
    WHERE r.name IN ('Nile','Amazonas','Yangtze','Rhein','Donau','Mississippi')

    UNION ALL

    -- Recursive case find tributaries flowing into the current river
    SELECT rt.mainriver, child.name AS currentriver, rt.path || '-' || child.name, rt.numrivers + 1, rt.totlength + child.length
    FROM river_tree rt
    JOIN River child ON child.river = rt.currentriver     -- child flows into parent
),
-- Find the longest branches (max numrivers) per main river
max_branch AS (
    SELECT mainriver, MAX(numrivers) AS maxamount
    FROM river_tree
    GROUP BY mainriver
)
SELECT 
    RANK() OVER (ORDER BY rt.numrivers ASC) AS rank, 
    rt.path, rt.numrivers, rt.totlength
FROM river_tree rt
JOIN max_branch mb ON rt.mainriver = mb.mainriver AND rt.numrivers = mb.maxamount
ORDER BY rank, totlength DESC;